# 1.0 - Planejamento e setup do login multi-tenant

## Resumo rápido
- Objetivo: consolidar premissas, dependências e riscos antes de implementar login multi-tenant e CRUD de usuários.
- Contexto PRD: login por e-mail/senha com checagem de usuário/tenant ativos, retorno de `tenantId` e `role`, CRUD API-first, mensagens em PT-BR, sem sessão.
- Tech Spec: rotas `/api/auth/login` e `/api/users`, uso de Supabase via `@supabase/supabase-js`, hash bcrypt custo 10, logs mínimos, front em `public/html/login.html`.

## Premissas confirmadas
- E-mail único global e normalizado (trim/lower); não altera após criação.
- Status em português: `'ativo'|'inativo'` para usuários e tenants.
- Endpoint de login: `POST /api/auth/login` com payload `{ email, senha }`; resposta genérica em falha.
- Hash de senha: adotaremos `bcryptjs` (já instalado) com custo 10 para evitar falha de build do `bcrypt` em Windows; manter API compatível para eventual troca por `bcrypt` em produção.
- Sem sessão/refresh token nesta entrega; apenas resposta de sucesso/erro.

## Fora de escopo (reforço)
- Middleware de proteção de rotas, rate limiting/captcha, recuperação/troca de senha, provedores sociais/SSO, UI para gestão de usuários, auditoria detalhada.

## Dependências e insumos
- Env vars obrigatórias: `SUPABASE_URL`, `SUPABASE_KEY` (carregadas via `.env` em `src/app.js` com `env.config({ path: ../.env })`).
- Cliente Supabase reutilizando `src/config/supabase.js`.
- Pacotes existentes: `express@5`, `@supabase/supabase-js@2`, `bcryptjs`, `dotenv`, `multer`. `nodemon` para dev.
- Modelo de dados (a definir na 2.0): tabelas `tenants` e `users` com índices (`email` único, `tenant_id`, `status`), status PT-BR.
- Front hospedado em `public/`; novas páginas/rotas de login ficarão em `public/html/login.html`, `public/js/login.js`, `public/css/login.css`.

## Riscos e mitigação provisória
- Build do bcrypt nativo em Windows: usar `bcryptjs`; revisar viabilidade de `bcrypt` no ambiente de produção antes do deploy.
- Rotas de CRUD sem autenticação nesta fase: restringir uso em ambiente com chave de serviço/IP allowlist; documentar risco até middleware futuro.
- Ausência de rate limiting expõe brute force: registrar contagem em logs e monitorar; mitigação definitiva em fase futura.
- Falta de env/Supabase indisponível: checagem de variáveis na inicialização e mensagens claras de erro.
- Consistência de status ativo/inativo entre usuário e tenant: validar ambos no serviço de auth.

## Sequência e paralelismo (tarefas X.0)
- 2.0 depende desta tarefa: DDL/índices e helpers de Supabase (normalização de e-mail/status).
- 3.0 (auth) e 4.0 (CRUD usuários) dependem de 2.0; podem evoluir em paralelo parcialmente após helpers.
- 5.0 (front login) depende de 3.0; pode iniciar markup básico em paralelo.
- 6.0 (seed) depende de 2.0; paralelizável com 5.0.
- 7.0 (logs) acompanha 3.0/4.0; 8.0 (testes) após 3.0/4.0/5.0.

## Próximos passos imediatos
1) Definir DDL e índices das tabelas `tenants` e `users`, incluindo check de status em PT-BR.  
2) Criar helpers de acesso Supabase (normalização de e-mail e status) em `src/services`/`repositories`.  
3) Decidir formato final de endpoints de status (rota dedicada vs `PATCH status`) antes de implementar 4.0.  
4) Preparar roteiro de testes manuais mínimos para validar escopo do PRD.  

